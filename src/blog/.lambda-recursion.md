---
title: 关于 lambda 表达式的递归
date: 2024-08-29 14:32:55
tags: 计算机
---

*有位恩师曾对我说过：“做研究最重要的是品位，写的文章要成为范式。不论水平高低，都要有这样的治学信心和野心。”写了半年的博客，除过几篇算法竞赛的题解，没有下笔写一篇关于计算机的文章——没什么拿的出手的小研究以撰写成文。而今天这篇《关于 lambda 表达式的递归》，是基于当前自己很满意的一个小探究。它代表了“品”与“位”：一行代码的简洁是大道至简之品；语言基础的奥妙是追本溯源之位。它并不是从无到有的发现，而是一份精心的探究。*

*单纯的应用是当下世界对计算机这门学科的认知。我固然承认这一种看法并理解应用是它的现实价值所在。但是，每一门学科研究至已臻化境、每一门技艺打磨到炉火纯青后都会展现它的艺术美。而我希望在我的求学与治学之路上，能够拾起沿途的每一份美感并留以记录。此篇作为我的计算机研究系列博客的处女作，希望它能作为给自己的范式昭示未来能够坚持贯彻的修养——追求美感。*

## 引入

有关于 ```lambda``` 表达式递归的话题来自 UCB CS61A homework 3 的任务 $6$。原任务如下：

### Q6: Anonymous Factorial

> This question demonstrates that it's possible to write recursive functions without assigning them a name in the global frame.

**The recursive factorial function can be written as a single expression by using a conditional expression.**

``` python
>>> fact = lambda n: 1 if n == 1 else mul(n, fact(sub(n, 1)))
>>> fact(5)
120
```

However, this implementation relies on the fact (no pun intended) that ```fact``` has a name, to which we refer in the body of ```fact```. To write a recursive function, we have always given it a name using a ```def``` or assignment statement so that we can refer to the function within its own body. In this question, your job is to define ```fact``` recursively without giving it a name!

Write an expression that computes n factorial using only call expressions, conditional expressions, and ```lambda``` expressions (no assignment or ```def``` statements).

> Note: You are not allowed to use make_anonymous_factorial in your return expression.

The ```sub``` and ```mul``` functions from the operator module are the only built-in functions required to solve this problem.

```python
from operator import sub, mul

def make_anonymous_factorial():
    """Return the value of an expression that computes factorial.

    >>> make_anonymous_factorial()(5)
    120
    >>> from construct_check import check
    >>> # ban any assignments or recursion
    >>> check(HW_SOURCE_FILE, 'make_anonymous_factorial',
    ...     ['Assign', 'AnnAssign', 'AugAssign', 'NamedExpr', 'FunctionDef', 'Recursion'])
    True
    """
    return 'YOUR_EXPRESSION_HERE'
```

Use Ok to test your code:

```sh
python3 ok -q make_anonymous_factorial
```

本文所指的 ```lambda``` 表达式递归是指不含任何赋值操作的 ```lambda``` 表达式递归。在 python 中，```lambda``` 表达式是函数的一种表达形式，由于只占一行，它大大提高了代码的简洁性，但不可避免地降低了代码的可读性和可维护性。一般地，在编写简单的模块时，可以用 ```lambda``` 表达式合理地简化代码。当然，以应用思维去思考 ```lambda``` 表达式和本文的主题递归便会发现 ```lambda``` 表达式的递归绝不是可读性和可维护性高的代码。不过，```lambda``` 表达式的递归更多地是一种理论和代表着一种思维：通过对 ```lambda``` 表达式的探究，我们可以窥见 python 语言本身的巧妙的设计。

## 结论

递归 $t$ 次、每次对 $k$ 执行 ```calc()``` 函数运算、递归终止条件为 ```condition(k)```、递归终止条件为真时返回值为 $1$ 的 ```lambda``` 表达式递归如下：

```python
lambda_recursion = (lambda t: (lambda n, k: n(n, k)) (lambda n, k: (stop_num if condition(k) else calc(n(n, k - 1), k)), t))
lambda_recursion (iritation_times)
```

函数 ```lambda_recursion``` 只是一个方便展示的演示函数（对于核心的函数递归而言可有可无）。

更具体些，以递归计算阶乘为例，```lambda``` 表达式的递归如下：

```python
lambda_recursion = (lambda t: (lambda n, k: n(n, k)) (lambda n, k: (1 if k <= 1 else n(n, k - 1) * k), t))
lambda_recursion (iritation_times)
```

## 理论

在探究 ```lambda``` 表达式时，很重要的一个点是 python 的函数的变量性。也就是说，在 python 中，函数可以作为一个变量，这就意味着函数可以作为一个变量被赋值、赋值、被传递于另一个函数、被另一个函数返回……更具体些，未执行的函数可以作为一个变量，而这个变量便是成为了这个函数，如：

```python
def demo_func (k)
    return k

f = demo_func

f(25)

F = f(demo_func)

F(25)
```

有：

```sh
25
25
```

## 逐层抽象

仍以递归解决阶乘问题为例子，展开对 ```lambda``` 表达式递归的分析。为了简化思考和调试的复杂程度，可以先用赋值和 ```def``` 来模拟 ```lambda``` 表达式递归。由于 ```lambda``` 表达式递归中不能出现赋值操作，每一个函数内不能出现对自己的调用。而递归的定义便是一个函数对自己的调用。这正是难点所在，也是看似的矛盾之处。而破局之处便在于对作用域的精妙运用。我们必须清楚，在 ```lambda``` 表达式递归的问题中，一个函数内的作用域只包含函数内的元素。也就是说，在函数的外层和本层没有任何元素，是空的。不难证明，由于限制了赋值操作，外层不可能有任何元素存在，而函数本层也没有定义这个函数。这时，我们只能着手于对函数内的元素进行操作。

当我们关注一个函数内部时，我们便很容易忽视函数的参数。而这恰恰是解决纯粹的 ```lambda``` 表达式递归的最关键之处。我们可以对一个函数传入另一个函数，而在函数内部执行这个被传入的函数，同时将这个函数作为参数传入——这样就做到了递归。接下来，我们可以再写一个类似思路的函数，同样传入一个函数，再调用它。只不过这个新写的函数将作为一个启动器，启动整个递归。最终，在简单封装成一个参数唯一的最终函数即可。例子如下：

### 具体层

```python
def A (n, k):
    print(f"in A: n={n}, k={k}")
    if k > 1:
        return n(n, k - 1) * k
    else:
        return 1

def B (n, k):
    return n(n, k)

def C (k):
    return B(A, k)

ANS = C (5)
print(ANS)
```

执行结果如下：

```sh
in A: n=<function A at 0x0000015DB5491CA0>, k=5
in A: n=<function A at 0x0000015DB5491CA0>, k=4
in A: n=<function A at 0x0000015DB5491CA0>, k=3
in A: n=<function A at 0x0000015DB5491CA0>, k=2
in A: n=<function A at 0x0000015DB5491CA0>, k=1
120
```

在上面的代码中，函数 ```A``` 是核心递归函数，$n$ 作为一个函数被传入，$k$ 表示递归的层。函数 ```B``` 是启动函数，本质上和 ```A``` 一样，只是没有终止条件。函数 ```C``` 是最终函数，使用函数 ```B``` 和 ```A```，只有一个参数——层数。注意，函数 ```C``` 里出现的函数 ```A``` 和函数 ```B``` 不能用调用这个词来描述，因为函数 ```A``` 和函数 ```B``` 完全可以被写进 ```C```。这里只是为了方便展示才单独写函数 ```A``` 和函数 ```B```。

### 结合 lambda 表达式

进一步抽象，将上面的函数写成 ```lambda``` 表达式的形式，如下。

```python
a = lambda n, k: (1 if k <= 1 else n(n, k - 1) * k)
b = lambda n, k: n(n, k)
c = lambda k: (b)(a, k)
```

### 整合 lambda 表达式

将用 $def$ 定义的函数写成 ```lambda``` 表达式的形式可以更方便地整合成一个 ```lambda``` 表达式。也就是上文所说，函数 ```a``` 和函数 ```b``` 可以被写进函数 ```c```。所以只需要把函数 ```c``` 中的 ```b``` 和 ```a``` 换成它们所对应的 ```lambda``` 表达式即可。

```python
lambda_recursion = (lambda t: (lambda n, k: n(n, k)) (lambda n, k: (1 if k <= 1 else n(n, k - 1) * k), t))
```
